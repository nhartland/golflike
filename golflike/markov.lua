-- markov.lua
-- Random word generation via basic markov-chain
local markov = {}

--- Process a corpus from a table
-- Expects as input a table of strings making up the text corpus.
-- `order` specifies the Markov-Chain order.
function markov.init(corpus, order)
    local map = {}
    map.initiators  = {} -- All initiating strings of length `order`
    map.terminators = {} -- All terminating strings of length `order`
    map.options = {}     -- Options form every order-length ngram
    map.order = order

    for _, word in ipairs(corpus) do
        if #word > order then
            for i=order, #word-1, 1 do
                local sprev =  word:sub(1+i-order,i):lower()
                local snext = word:sub(i+1,i+1):lower()
                -- Count terminating sequences
                if i == #word - 1 then
                    local term = (sprev..snext):sub(2)
                    if map.terminators[term] == nil then
                        map.terminators[term] = 1
                    else
                        map.terminators[term] = map.terminators[term] + 1
                    end
                end
                -- Count options
                if map.options[sprev] == nil then
                    map.options[sprev] = {snext}
                    if i == order then
                        table.insert(map.initiators, sprev)
                    end
                else
                    table.insert(map.options[sprev], snext)
                end
            end
        end
    end
    return map
end

--- Generate a word according to an existing corpus map
-- @param map a corpus generated by markov.init
-- @rng (optional) a random number generator table that can be called as math.random
-- @return the word and a boolean specifying whether the word is correctly terminated or not
function markov.word(map, rng)
    if rng == nil then rng = math.random end
    local order = map.order
    local word = map.initiators[rng(#map.initiators)]
    while true do
        local sprev = word:sub(#word-order+1)
        local p_terminate = map.terminators[sprev]
        if p_terminate == nil then p_terminate = 0 end
        local poss_letter = map.options[sprev]
        if poss_letter == nil then return word, p_terminate ~= nil end -- Potentially not a terminator
        local choice = rng(p_terminate + #poss_letter)
        local next_letter = poss_letter[choice]
        if next_letter == nil then return word, true end -- Definately a terminator
        word = word .. next_letter
    end
    return word
end

return markov

